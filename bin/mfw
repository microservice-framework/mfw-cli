#!/usr/bin/env node

'use strict';

const commander = require('commander');
const path = require('path');
const fs = require('fs');
const pkg = require('../package.json');
const Message = require('../includes/message.js');
const MFWCli = require('../includes/MFWCliClass.js');
const status = require('../includes/MFWCliStatus.js');
const client = require('../includes/MFWClient.js');
const exec = require('child_process').exec;

commander.version(pkg.version).usage('[cmd] [options] [mode]');

commander.command('setup [dir]')
  .description('setup directory')
  .option('-e, --env <name>', 'Environment. Helps to separate production, stage, devel.')
  .action(setupDir);

commander.command('install <service>')
  .description('Install microservice. Use "all" to install all services saved in package.json.')
  .option('-r, --root <dir>', 'Optionaly root directory')
  .option('-s, --save', 'Save microservice information')
  .option('-d, --default', 'Set default values')
  .action(installService);

commander.command('update <service>')
  .description('Update microservice. Use "all" to install all services saved in package.json.')
  .option('-r, --root <dir>', 'Optionaly root directory')
  .action(updateService);

commander.command('uninstall <service>')
  .description('Uninstall microservice')
  .option('-r, --root <dir>', 'Optionaly root directory')
  .option('-s, --save', 'Save microservice information')
  .action(uninstallService);

commander.command('env [env]')
  .description('setup env directory')
  .option('-l, --list', 'List enabled Environments.')
  .option('-e, --extended', 'Print extended info')
  .option('-r, --root <dir>', 'Optionaly root directory')
  .action(envList);

commander.command('start <service>')
  .description('Start microservice(s). Use "all" to install all services saved in package.json.')
  .option('-r, --root <dir>', 'Optionaly root directory')
  .option('-d, --devel', 'Optionaly devel mode')
  .action(startService);

commander.command('stop <service>')
  .description('Stop microservice(s). Use "all" to install all services saved in package.json.')
  .option('-r, --root <dir>', 'Optionaly root directory')
  .action(stopService);

commander.command('status [service]')
  .description('Microservice(s) status')
  .option('-r, --root <dir>', 'Optionaly root directory')
  .action(status.Status);

commander.command('client-create <service> <JSONDATA>')
  .description('Create resource in service.')
  .option('-r, --root <dir>', 'Optionaly root directory')
  .option('-t, --token <token>', 'Optionaly token. If no token provided, SECURE_KEY used.')
  .option('-a, --accesstoken <accesstoken>',
    'Optionaly access token. If no token provided, SECURE_KEY used instead.')
  .action(client.clientPOST);

commander.command('client-read <service> <id>')
  .description('Read resource by ID from service.')
  .option('-r, --root <dir>', 'Optionaly root directory')
  .option('-t, --token <token>', 'Optionaly token.')
  .option('-a, --accesstoken <accesstoken>', 'Optionaly access token.')
  .action(client.clientGet);

commander.command('client-update <service> <id> <JSONDATA>')
  .description('Update resource by ID for service.')
  .option('-r, --root <dir>', 'Optionaly root directory')
  .option('-t, --token <token>', 'Optionaly token. If no token provided, SECURE_KEY used.')
  .option('-a, --accesstoken <accesstoken>',
    'Optionaly access token. If no token provided, SECURE_KEY used instead.')
  .action(client.clientPUT);

commander.command('client-delete <service> <id>')
  .description('Delete resource by ID from service.')
  .option('-r, --root <dir>', 'Optionaly root directory')
  .option('-t, --token <token>', 'Optionaly token.')
  .option('-a, --accesstoken <accesstoken>', 'Optionaly access token.')
  .action(client.clientDEL);

commander.command('client-search <service> <JSONDATA>')
  .description('Search resource in service.')
  .option('-r, --root <dir>', 'Optionaly root directory')
  .option('-t, --token <token>', 'Optionaly token. If no token provided, SECURE_KEY used.')
  .option('-a, --accesstoken <accesstoken>',
    'Optionaly access token. If no token provided, SECURE_KEY used instead.')
  .action(client.clientSEARCH);


commander.parse(process.argv);

if (process.argv.length == 2) {
  commander.outputHelp();
}

/**
 * Process setup command.
 */
function setupDir(rootDIR, options) {
  if (!rootDIR) {
    rootDIR = process.cwd();
  }
  var rootDIR = path.resolve(rootDIR);
  var envName = options.env;
  if (!envName) {
    envName = '';
  }

  MFWCli.setup(rootDIR, envName);
}

/**
 * Process install command.
 */
function installService(service, options) {
  var rootDIR = getRoot(options);
  MFWCli.install(rootDIR, service, options.save, options.default);
}

/**
 * Process update command.
 */
function updateService(service, options) {
  var rootDIR = getRoot(options);
  if (service != 'all') {
    return MFWCli.update(rootDIR, service);
  }
  MFWCli.updateAll(rootDIR);
}

/**
 * Process uninstall command.
 */
function uninstallService(service, options) {
  var rootDIR = getRoot(options);
  MFWCli.uninstall(rootDIR, service, options.save);
}

/**
 * Process start command.
 */
function startService(service, options) {
  var rootDIR = getRoot(options);
  if (!service) {
    service = 'all';
  }
  MFWCli.start(rootDIR, service, options.devel);
}

/**
 * Process stop command.
 */
function stopService(service, options) {
  var rootDIR = getRoot(options);
  if (!service) {
    service = 'all';
  }
  MFWCli.stop(rootDIR, service);
}

/**
 * Process env command.
 */
function envList(envName, options) {
  var rootDIR = getRoot(options);
  if (envName) {
    if (envName == 'default') {
      envName = '';
    }
    return MFWCli.envSet(rootDIR, envName);
  }
  if (options.list) {
    var envs = findEnvironments(rootDIR, options.extended);
    console.log(envs);
  }
}

/**
 * Get Root directory based on command options.
 */
function getRoot(options) {
  var rootDIR = options.root;
  if (!rootDIR) {
    rootDIR = process.cwd();
  }
  return path.resolve(rootDIR);
}

/**
 * Find env packages.
 */
function findEnvironments(startPath, isExtended) {

  var results = {};
  var filter = 'package.json';

  if (!fs.existsSync(startPath)) {
    return;
  }

  var files = fs.readdirSync(startPath);
  for (var i = 0; i < files.length; i++) {
    var filename = files[i];
    var index = filename.indexOf(filter);
    var packageJSON = '';
    if (index >= 0) {
      if (isExtended) {
        try {
          packageJSON = JSON.parse(fs.readFileSync(path.join(startPath,filename)));
        } catch (e) {
          return console.log(e);
        }
      } else {
        packageJSON = filename;
      }
    }
    if (index == 0) {
      results['default'] = packageJSON;
    }
    if (index > 0) {
      var env = filename.substring(0,index - 1);
      results[env] = packageJSON;
    }
  }
  return results;
}
